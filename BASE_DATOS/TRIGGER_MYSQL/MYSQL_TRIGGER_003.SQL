***************************************
***   INTRODUCCION A LOS TRIGGERS   ***
***************************************
--------------------------------------------------------------------------------
(1) ¬øQUE ES UN TRIGGER?

Un trigger (o "disparador" en espa√±ol) es un bloque de c√≥digo SQL que se ejecuta 
autom√°ticamente antes o despu√©s de que ocurra un evento espec√≠fico en  una tabla 
(como INSERT, UPDATE o DELETE).

Ejemplo cotidiano: Imagina un  vigilante  en un  edificio (la base de datos) que 
act√∫a cuando alguien intenta entrar, modificar algo o salir (eventos en la tabla).
--------------------------------------------------------------------------------
(2) ¬øPARA QUE SIRVE?

Los triggers se usan principalmente para:

‚úÖ Validar datos:

Ejemplo: Evitar que se ingrese un salario negativo en una tabla de empleados.

‚úÖ Automatizar procesos:

Ejemplo: Actualizar autom√°ticamente la fecha de modificaci√≥n cuando un registro cambie.

‚úÖ Registrar auditor√≠as:

Ejemplo: Guardar en otra tabla qui√©n elimin√≥ un dato importante.

‚úÖ Mantener integridad referencial:

Ejemplo: Si se borra un cliente, borrar tambi√©n sus pedidos asociados.
--------------------------------------------------------------------------------
(3) VENTAJAS Y DESVENTAJAS

-- VENTAJAS

‚úî Automatizaci√≥n: Reducen la necesidad de escribir c√≥digo repetitivo en la aplicaci√≥n.
‚úî Seguridad: Permiten aplicar reglas de negocio directamente en la base de datos.
‚úî Consistencia: Aseguran que ciertas acciones siempre se ejecuten (ej: auditor√≠as).

-- DESVENTAJAS

‚ùå Dificultad para depurar: Si hay un error en un trigger, puede ser complicado rastrearlo.
‚ùå Impacto en el rendimiento: Si son muy complejos, pueden hacer lenta la base de datos.
‚ùå Dependencia oculta: Alguien que modifique la tabla podr√≠a no saber que hay un trigger asociado.
--------------------------------------------------------------------------------
(4) EJEMPLO CON UNA ANALOGIA

Piensa en un trigger como un bot de WhatsApp que:

Se activa cuando recibes un mensaje (evento INSERT).
Verifica si el mensaje tiene palabras prohibidas (BEFORE INSERT).
Guarda un registro de qui√©n lo envi√≥ (AFTER INSERT).

Los triggers son como "guardianes autom√°ticos" de tu base de datos. Son  √∫tiles, 
pero deben usarse con cuidado para no complicar el sistema.
--------------------------------------------------------------------------------
*****************************************
***   SINTAXIS BASICA DE UN TRIGGER   ***
*****************************************
--------------------------------------------------------------------------------
CREATE TRIGGER nombre_trigger
BEFORE/AFTER INSERT/UPDATE/DELETE ON tabla
FOR EACH ROW
BEGIN
    -- C√≥digo a ejecutar
END;
--------------------------------------------------------------------------------
*****************************
***   TIPOS DE TRIGGERS   ***
*****************************
--------------------------------------------------------------------------------
-- TIPOS DE TRIGGERS

Seg√∫n el momento de ejecuci√≥n:

BEFORE (antes de la operaci√≥n).

AFTER (despu√©s de la operaci√≥n).

Seg√∫n la operaci√≥n que lo activa:

INSERT (al insertar datos).

UPDATE (al actualizar datos).

DELETE (al eliminar datos).
--------------------------------------------------------------------------------
-- RESUMEN DE COMBINACIONES

---------------------------------------------------------------
MOMENTO		OPERACION   	USO TIPICO
---------------------------------------------------------------
BEFORE		INSERT			Validar datos antes de guardar.
AFTER		INSERT			Registrar en logs o auditor√≠a.
BEFORE		UPDATE			Actualizar campos autom√°ticamente.
AFTER		UPDATE			Registrar cambios importantes.
BEFORE		DELETE			Evitar eliminaciones no permitidas.
AFTER		DELETE			Guardar respaldo de datos borrados.
---------------------------------------------------------------
--------------------------------------------------------------------------------
*****************************************************
***   BASE DE DATOS PARA LOS EJEMPLOS PRACTICOS   ***
*****************************************************

-- Crear la base de datos
DROP DATABASE IF EXISTS TIENDAONLINE;
CREATE DATABASE IF NOT EXISTS TIENDAONLINE;
USE TIENDAONLINE;

-- Tabla de productos
CREATE TABLE Producto (
    id_producto         INT                     AUTO_INCREMENT PRIMARY KEY,
    nombre              VARCHAR(100)   NOT NULL,
    precio              DECIMAL(10, 2) NOT NULL,
    stock               INT            NOT NULL,
    fecha_actualizacion TIMESTAMP      
);

-- Tabla de pedidos
CREATE TABLE Pedido (
    id_pedido    INT                                          AUTO_INCREMENT PRIMARY KEY,
    id_producto  INT                                 NOT NULL,
    cantidad     INT                                 NOT NULL,
    fecha_pedido TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
                 FOREIGN KEY (id_producto) REFERENCES Producto(id_producto)
);

-- Tabla de auditor√≠a (para triggers AFTER)
CREATE TABLE Auditoria (
    id_auditoria   INT                   AUTO_INCREMENT PRIMARY KEY,
    accion         VARCHAR(100) NOT NULL,
    tabla_afectada VARCHAR(50)  NOT NULL,
    id_registro    INT          NOT NULL,
    fecha          TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla de respaldo para productos eliminados
CREATE TABLE Productos_Eliminados (
    id                INT,
    nombre            VARCHAR(100),
    precio            DECIMAL(10, 2),
    fecha_eliminacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
*********************************************************
***   EJEMPLOS DE TRIGGERS PARA LAS 6 COMBINACIONES   ***
*********************************************************
--------------------------------------------------------------------------------
-- 1. BEFORE INSERT ‚Üí VALIDAR DATOS ANTES DE INSERTAR

-- OBJETIVO: ASEGURAR QUE EL PRECIO DE UN PRODUCTO NO SEA NEGATIVO

DROP TRIGGER before_insert_producto;
DELIMITER //
CREATE TRIGGER before_insert_producto
BEFORE INSERT ON Producto
FOR EACH ROW
BEGIN
    IF NEW.precio < 0 THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'Error: El precio no puede ser negativo';
    END IF;
END //
DELIMITER ;

-- PRUEBA:

INSERT INTO Producto (nombre, precio, stock) VALUES ('Laptop', -1000, 5); -- Error Esto lanza un error y no inserta el registro
INSERT INTO Producto (nombre, precio, stock) VALUES ('Laptop', 1000, 5);  -- Correcto

-- EXPLICACION:

 DELIMITER //
¬øQu√© hace?: Cambia el delimitador de comandos de ; a //.

¬øPor qu√©?: Para poder escribir todo el trigger (que contiene m√∫ltiples ;) como una √∫nica unidad de c√≥digo, sin que MySQL lo ejecute antes de terminar.

üîπ CREATE TRIGGER before_insert_producto
¬øQu√© hace?: Comienza la creaci√≥n de un trigger llamado before_insert_producto.

¬øCu√°ndo se activa?: Antes de insertar una fila en la tabla Producto.

üîπ BEFORE INSERT ON Producto
¬øQu√© hace?: Especifica que el trigger se ejecutar√° antes (BEFORE) de una operaci√≥n de inserci√≥n (INSERT) en la tabla Producto.

üîπ FOR EACH ROW
¬øQu√© hace?: Indica que el trigger se aplica a cada fila que se quiera insertar (es decir, fila por fila).

üîπ BEGIN ... END
¬øQu√© hace?: Marca el bloque de instrucciones que se ejecutar√°n cuando se active el trigger.

üîπ IF NEW.precio < 0 THEN
¬øQu√© hace?: Verifica si el valor del campo precio de la nueva fila (NEW.precio) es menor que 0.

NEW: Hace referencia a los valores que se est√°n intentando insertar.

üîπ SIGNAL SQLSTATE '45000'
¬øQu√© hace?: Lanza un error personalizado.

SQLSTATE '45000': Es un c√≥digo gen√©rico que indica un error definido por el usuario.

üîπ SET MESSAGE_TEXT = 'Error: El precio no puede ser negativo';
¬øQu√© hace?: Especifica el mensaje de error que se mostrar√° si se cumple la condici√≥n del IF.

Estos dos l√≠neas deben estar juntas siempre:
SIGNAL SQLSTATE '45000': '45000' es un c√≥digo gen√©rico para errores definidos por el usuario.
SET MESSAGE_TEXT = ...: especifica el mensaje de error que se mostrar√°.

üîπ END IF;
¬øQu√© hace?: Finaliza la instrucci√≥n condicional IF.

üîπ END //
¬øQu√© hace?: Finaliza el bloque del trigger.

üîπ DELIMITER ;
¬øQu√© hace?: Restaura el delimitador de comandos al valor por defecto (;).

‚úÖ ¬øQu√© logra este trigger?
Evita que se inserte en la tabla Producto cualquier registro con un precio negativo. Si alguien intenta hacerlo, se genera un error con el mensaje:

Error: El precio no puede ser negativo

-- EXPLICACION:

Tu trigger:

DELIMITER //
CREATE TRIGGER before_insert_producto
BEFORE INSERT ON Producto
FOR EACH ROW
BEGIN
    IF NEW.precio < 0 THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'Error: El precio no puede ser negativo';
    END IF;
END //
DELIMITER ;

‚úÖ ¬øQu√© hace este trigger?

Este trigger se ejecuta antes de insertar un nuevo registro en la tabla Producto. Su objetivo es:

Validar que el valor de precio no sea negativo.

Si precio < 0, lanza un error y bloquea la inserci√≥n del registro.

üîç ¬øPor qu√© no se puede insertar un registro con precio < 0?
Porque est√°s usando:

SIGNAL SQLSTATE '45000' 
SET MESSAGE_TEXT = 'Error: El precio no puede ser negativo';

Esto hace que MySQL:

Interrumpa la operaci√≥n de INSERT.

Devuelva un error personalizado.

Entonces, si intentas hacer algo como:

INSERT INTO Producto (nombre, precio) VALUES ('Coca-Cola', -5);

MySQL responder√° con:

ERROR 1644 (45000): Error: El precio no puede ser negativo
Y no insertar√° el producto.
--------------------------------------------------------------------------------
-- 2. AFTER INSERT ‚Üí REGISTRAR EN AUDITORIA TRAS INSERTAR

-- OBJETIVO: GUARDAR UN LOG CUANDO SE AGREGUE UN NUEVO PRODUCTO.

DROP TRIGGER after_insert_producto;
DELIMITER //
CREATE TRIGGER after_insert_producto
AFTER INSERT ON Producto
FOR EACH ROW
BEGIN
    INSERT INTO auditoria (accion, tabla_afectada, id_registro)
    VALUES ('Nuevo producto insertado', 'producto', NEW.id_producto);
END //
DELIMITER ;

-- PRUEBA:


INSERT INTO Producto (nombre, precio, stock) VALUES ('Mouse', 25.99, 10);
SELECT * FROM auditoria; -- Debe aparecer un registro
--------------------------------------------------------------------------------
-- 3. BEFORE UPDATE ‚Üí ACTUALIZAR FECHA AUTOM√ÅTICAMENTE

-- OBJETIVO: ACTUALIZAR FECHA_ACTUALIZACION ANTES DE MODIFICAR UN PRODUCTO.

DROP TRIGGER before_update_producto;
DELIMITER //
CREATE TRIGGER before_update_producto
BEFORE UPDATE ON Producto
FOR EACH ROW
BEGIN
    SET NEW.fecha_actualizacion = NOW();
END //
DELIMITER ;

-- PRUEBA:

UPDATE Producto SET precio = 30.50 WHERE nombre = 'Mouse';
SELECT * FROM Producto WHERE nombre = 'Mouse'; -- Verificar fecha_actualizacion

-- ANTES ESTO PARA QUE FUNCIONE EL EJEMPLO:

SET SQL_SAFE_UPDATES = 0;

SELECT * FROM Producto;

INSERT INTO Producto (nombre, precio, stock, fecha_actualizacion)
VALUES ('Mouse', 25.00, 50, NOW());

-- EXPLICACION:

Cuando ejecutas una sentencia como:

UPDATE Producto SET precio = 50 WHERE id = 1;

y tienes este trigger:

CREATE TRIGGER before_update_producto
BEFORE UPDATE ON Producto
FOR EACH ROW
BEGIN
    SET NEW.fecha_actualizacion = NOW();
END;

¬øQu√© sucede internamente?

Antes de que MySQL actualice el registro en la tabla Producto, se ejecuta el trigger BEFORE UPDATE.

El trigger modifica el valor del campo fecha_actualizacion del nuevo registro usando SET NEW.fecha_actualizacion = NOW();.

Luego, MySQL contin√∫a con la actualizaci√≥n original, por ejemplo, cambiando el precio.

Al final, el registro queda actualizado con:

El nuevo precio que diste en el UPDATE.

La fecha_actualizacion con la hora exacta en la que se hizo la modificaci√≥n.
--------------------------------------------------------------------------------
-- 4. AFTER UPDATE ‚Üí REGISTRAR CAMBIOS DE STOCK

-- OBJETIVO: GUARDAR EN AUDITOR√çA SI EL STOCK DE UN PRODUCTO CAMBIA.

DROP TRIGGER after_update_producto;
DELIMITER //
CREATE TRIGGER after_update_producto
AFTER UPDATE ON Producto
FOR EACH ROW
BEGIN
    IF OLD.stock != NEW.stock THEN
        INSERT INTO auditoria (accion, tabla_afectada, id_registro)
        VALUES ('Stock actualizado', 'Producto', NEW.id_producto);
		
		
    END IF;
END //
DELIMITER ;

-- PRUEBA:

UPDATE Producto SET stock = 8 WHERE nombre = 'Mouse';
SELECT * FROM auditoria; -- Debe aparecer un nuevo registro
--------------------------------------------------------------------------------
-- 5. BEFORE DELETE ‚Üí EVITAR ELIMINAR PRODUCTOS CON STOCK

-- OBJETIVO: NO PERMITIR BORRAR PRODUCTOS CON STOCK MAYOR A CERO.

DROP TRIGGER before_delete_producto;
DELIMITER //
CREATE TRIGGER before_delete_producto
BEFORE DELETE ON Producto
FOR EACH ROW
BEGIN
    IF OLD.stock > 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'No se puede eliminar: El producto a√∫n tiene stock';
    END IF;
END //
DELIMITER ;

-- PRUEBA:

DELETE FROM Producto WHERE nombre = 'Mouse'; -- Error si stock > 0
UPDATE Producto SET stock = 0 WHERE nombre = 'Mouse'; -- Primero reducir stock
DELETE FROM Producto WHERE nombre = 'Mouse'; -- Ahora s√≠ funciona 
SELECT * FROM Producto; -- Verificar que se haya eliminado
--------------------------------------------------------------------------------
-- 6. AFTER DELETE ‚Üí GUARDAR RESPALDO DE PRODUCTOS ELIMINADOS

-- OBJETIVO: COPIAR EL PRODUCTO ELIMINADO EN PRODUCTOS_ELIMINADOS.

DROP TRIGGER after_delete_producto
DELIMITER //
CREATE TRIGGER after_delete_producto
AFTER DELETE ON Producto
FOR EACH ROW
BEGIN
    INSERT INTO Productos_Eliminados (id, nombre, precio)
    VALUES (OLD.id_producto, OLD.nombre, OLD.precio);
END //
DELIMITER ;

-- PRUEBA:

DELETE FROM Producto WHERE nombre = 'Teclado';
SELECT * FROM productos_eliminados; -- Debe aparecer el Mouse eliminado
SELECT * FROM Producto; -- Verificar que se haya eliminado

-- ANTES INSERTAR MOUSE PARA PROBAR EL EJEMPLO

INSERT INTO Producto (nombre, precio, stock, fecha_actualizacion)
VALUES ('Teclado', 25.00, 0, NOW());
--------------------------------------------------------------------------------

















